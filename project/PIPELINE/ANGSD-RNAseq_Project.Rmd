---
title: "ANGSD: RNAseq Project"
author: "Shaun"
date: "2024-04-01"
output: 
  html_document:
    code_folding: show
    theme: cosmo
    toc: true
    toc_depth: 2
    toc_float: true
editor_options: 
  chunk_output_type: console
---


## 1. Data record

My project was inspired by the paper entilted, [RNA sequencing analysis of the developing chicken retina](https://www.nature.com/articles/sdata2016117#Sec10) which was published in Scientific Data in 2016. The transcriptomic data discussed in the paper was deposited in NCBI Gene Expression Omnibus (GEO) under the accession number [GSE65938](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE65938). In short, the data was generated by James Madison University’s Center for Genome & Metagenome Studies (CGEMS) and the experiments were conducted with approval from the James Madison University Institutional Animal Care and Use Committee and adhered to the guidelines outlined in the National Institutes of Health guide for the care and use of laboratory animals. RNA extraction was performed from eight embryonic chicken ocular tissues, including whole retinas from E8, E16, and E18 developing chicken embryos, as well as whole corneas collected from E18 embryos. Duplicates were obtained for each time point, and total RNA was extracted using a Qiagen AllPrep Mini Kit, following the manufacturer’s instructions. cDNA libraries were prepared using a poly dT primer, thus the data set is representative of only polyadenylated mRNA transcripts and does not represent non-coding RNA or other non-polyadenylated cellular transcripts. Finally, Illumina Next Generation Sequencing (NGS) technology was utilized for sequencing the RNA samples, providing high-throughput and accurate transcriptomic data acquisition.



## 2. Begining to download the data

*downloading script is located in the following directory, or in the scripts folder in GitHub.*

To acquire the data, I began by storing all the accession numbers from GEO into a file using the SRA run selector (accession_list.txt). This step allowed me to execute my script for downloading the data. In total, I obtained 8 samples that represent various embryonic time points from both the chicken's retina and cornea.

```{bash, eval=FALSE}
(angsd) bash-4.4$ nano accession_list.txt
SRR1804235
SRR1804236
SRR1804237
SRR1804238
SRR1804239
SRR1804240
SRR1804241
SRR1804242
```


```{bash, eval=FALSE}
(angsd) bash-4.4$ nano sra_download.sh 
(angsd) bash-4.4$ chmod u+x sra_download.sh 

#!/bin/bash
accession_num=$(cat accession_list.txt)

# make new directory to hold fastq files
#mkdir fastq
#cd fastq

# Read accession numbers from the file and iterate over them
while read -r accession_num; do
    echo "$accession_num"  # Print each accession number before downloading
    fasterq-dump "$accession_num" -F fastq -O fastq --skip-technical --split-3 --threads 3
done < accession_list.txt

echo "All downloads complete :)"
```


## 3. Quality Control: fastQC and MultiQC

*running fastQC and multiQC on my raw files script is located in the following directory: /athena/angsd/scratch/shp4022/angsd_project/project/fastq/fastqc_multiqc.sh, or in the scripts folder in my GitHub repository.*

To assess the quality of the downloaded samples, I developed a script that executes both `fastQC` and `multiQC` on each of my samples.

```{bash, eval=FALSE}
for file in *_*.fastq; do fastqc "$file"; done 

multiqc *_fastqc.zip

```

<iframe src="./Fastqc/multiqc_report_fastqc.pdf" width="100%" height="600"></iframe>

The `multiQC` report indicates low adapter content across all my samples. Therefore, I made the decision not to trim my reads.



## 4. Alignment using STAR

*genome generate script is located in the following directory: /athena/angsd/scratch/shp4022/angsd_project/project/genome/STAR_genomeGenerate.sh, or in the scripts folder in my GitHub repository.*

Before aligning my reads, I downloaded the chicken genome [galGal6](https://hgdownload.soe.ucsc.edu/goldenPath/galGal6/bigZips/)  and indexed it. While my paper originally utilized galGal4, which was likely the latest version available at the time, the authors mentioned that galGal6 would also be compatible. Considering that galGal6 likely offers a more comprehensive genome than galGal4, and since the paper explicitly stated that galGal6 would suffice, I opted to utilize galGal6 for my analysis.

```{bash, eval=FALSE}
STAR --runMode genomeGenerate \
     --runThreadN 5 \
     --genomeDir galGal6_STAR_Index \
     --genomeFastaFiles galGal6.fa \
     --sjdbGTFfile galGal6.ncbiRefSeq.gtf \
     --sjdbOverhang 99 \
```


--runThreadN 5: Number of threads

--runMode genomeGenerate: This tells STAR to run in genome indexing mode.

--genomeDir "galGal6_STAR_Index": Specifies the directory where the generated genome indices will be stored.

--genomeFastaFiles "galGal6.fa": Specifies the path to the FASTA files containing the reference genome sequences.

--sjdbGTFfile "galGal6.ncbiRefSeq.gtf": Specifies the path to the GTF file containing the genome annotation.

--sjdbOverhang 99: This parameter sets the length of the genomic sequence around the annotated junction to be used in constructing the splice junctions database.



Running STAR using my script:

*alignment script is located in the following directory: /athena/angsd/scratch/shp4022/angsd_project/project/Alignment/STAR_align.sh, or in the scripts folder in my GitHub repository.*

```{bash, eval=FALSE}
#!/bin/bash

# E8 retina rep 1 Align reads

STAR --runMode alignReads \
     --outFilterMultimapNmax 20 \
     --runThreadN 8 \
     --outFileNamePrefix E8_retina_rep1_ \
     --genomeDir ../genome/galGal6_STAR_Index \
     --readFilesIn ../fastq/SRR1804237_1.fastq.gz ../fastq/SRR1804237_2.fastq.gz \
     --readFilesCommand zcat \
     --outFilterType BySJout \
     --outSAMtype BAM SortedByCoordinate \
     --outSAMattributes NH HI AS nM MD


# E8 retina rep 2 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E8_retina_rep2_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804238_1.fastq.gz ../fastq/SRR1804238_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD

# E16 retina rep 1 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E16_retina_rep1_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804235_1.fastq.gz ../fastq/SRR1804235_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD

# E16 retina rep 2 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E16_retina_rep2_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804236_1.fastq.gz ../fastq/SRR1804236_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD

# E18 retina rep 1 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E18_retina_rep1_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804239_1.fastq.gz ../fastq/SRR1804239_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD


# E18 retina rep 2 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E18_retina_rep2_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804240_1.fastq.gz ../fastq/SRR1804240_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD


# E18 cornea rep 1 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E18_cornea_rep1_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804241_1.fastq.gz ../fastq/SRR1804241_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD

# E18 cornea rep 2 Align reads

STAR --runMode alignReads \
--outFilterMultimapNmax 20 \
--runThreadN 8 \
--outFileNamePrefix E18_cornea_rep2_ \
--genomeDir ../genome/galGal6_STAR_Index \
--readFilesIn ../fastq/SRR1804242_1.fastq.gz ../fastq/SRR1804242_2.fastq.gz \
--readFilesCommand zcat \
--outFilterType BySJout \
--outSAMtype BAM SortedByCoordinate \
--outSAMattributes NH HI AS nM MD
```

My choices for options to include were influenced by the script that was in my paper.

--runMode alignReads: This specifies the operation mode of STAR. alignReads tells STAR to perform the read alignment against the prepared genome index.

--runThreadN 8: Number of threads

--genomeDir "galGal6_STAR_Index": This sets the path to the directory containing the genome index files that were previously generated with STAR in genomeGenerate mode.

--readFilesIn "$sample.fastq.gz": Specifies the input files containing the RNAseq reads.

--outFileNamePrefix: This parameter sets the prefix for all output files generated by STAR.

--outSAMtype BAM SortedByCoordinate: This tells STAR to output the alignment results in BAM format, sorted by genomic coordinates. 

--outFilterMultimapNmax: maximum number of loci the read is allowed to map to.

--outSAMattributes: specify SAMtags

outFilterType: BySJout ... keep only those reads that contain junctions that passed filtering into SJ.out.tab


After this, I ran `bamQC` on my alignment files. Below, I show one of those reports for one sample.

<iframe src="./E16_retina_rep1.report.pdf" width="100%" height="600"></iframe>


*bamQC script is located in the following directory: /athena/angsd/scratch/shp4022/angsd_project/project/Alignment/align_qc.sh , or in the scripts folder in my GitHub repository.*

```{bash, eval=FALSE}
#!/bin/bash
for file in *.bam; do
        name=$(echo "$file" | sed "s/_Aligned.sortedByCoord.out.bam//")

        if [[ ! -f "$name.report.pdf" ]]; then
                qualimap bamqc -bam $file -outformat pdf -outfile "$name.report.pdf" -outdir /athena/angsd/scratch/shp4022/project/Alignment/Alignment_qc &
        fi
done

wait
```


```{r, out.width="100%"}
knitr::include_graphics("./E16_retina_rep1.report.pdf")
```

I also executed `multiQC` on my *final.out* files to generate a report detailing the mapping status of my reads, including information on mapped, unmapped, and multimapped reads, among others.

<iframe src="./multiqc_report_align.pdf" width="100%" height="600"></iframe>


## 5. Feature Counts

*feature counts script is located in the following directory: /athena/angsd/scratch/shp4022/angsd_project/project/Alignment/fc.sh , or in the scripts folder in my GitHub repository.*

Next, I will execute `featureCounts` on my samples to evaluate gene mapping and conduct downstream analyses such as differential gene expression (DGE).

```{bash, eval=FALSE}
#!/bin/sh

featureCounts -F GTF -g gene_id -t exon -T 32 -a ../genome/galGal6.ncbiRefSeq.gtf \
        -o ../featureCount_results/featureCounts.txt -s 1 -p -B *_Aligned.sortedByCoord.out.bam
```


--F "GTF": Specify format of the provided annotation file.

--g "gene_id":  Specify attribute type in GTF annotation

--t "exon": Specify feature type(s) in a GTF annotation.

--T "32": Number of threads

--a "galGal6.ncbiRefSeq.gtf": Name of an annotation file.

--o "../featureCount_results/featureCounts.txt": Name of output file including read counts

--s "1": Perform strand-specific read counting. '1' (stranded)

--p: If specified, libraries are assumed to contain paired-end reads.

--B: Only count read pairs that have both ends aligned.


## 6. Processing Feature Counts in Rstudio

```{r}
suppressMessages(library(ggplot2))
suppressMessages(library(tidyverse))
suppressMessages(library(dplyr))
suppressMessages(library(plotly))
suppressMessages(library(DESeq2))
suppressMessages(library(DT))
```

**Version Control:**
```{r}
sessionInfo()
```


The following commands below will allow me to generate a read count table based on my `featureCounts` data.

```{r}
# setwd("/Users/shaunp/Desktop/Weill_Cornell_Graduate/Grad_School/SPRING_2024/Analysis_Next-Gen_Sequencing_Data/Project")
read_counts <- read.table(file = "featureCounts.txt.summary", 
                          header = TRUE)
```


```{r}
read_counts %>% 
  head(5) %>%
  DT::datatable()
```


```{r}
read_counts %>%
  dplyr::slice(c(1, 9, 12, 14)) -> read_counts

names(read_counts) %>%
  stringr::str_remove("_Aligned.sortedByCoord.out.bam") -> names(read_counts)

names(read_counts) %>%
  stringr::str_extract("\\d$") %>%
  #as.character() %>%
  stringr::str_replace_na(replacement = "rep#") -> rep_number
  #c("rep#") %>%
  #.[1:10] %>%
  #stringr::str_c("rep#")
  #append(values = "rep#", before = "1") -> rep_number

# names(read_counts) |>
#   stringr::str_remove("_rep\\d") -> names(read_counts)
  
# read_counts %>%
#   rbind(rep_number) -> read_counts

read_counts %>%
  dplyr::relocate(E8_retina_rep1, .before = E16_retina_rep1) %>%
  dplyr::relocate(E8_retina_rep2, .after = E8_retina_rep1) %>%
  dplyr::relocate(E18_retina_rep1, .before = E18_cornea_rep1) %>%
  dplyr::relocate(E18_retina_rep2, .after = E18_retina_rep1) -> read_counts


read_counts %>%
  head(5) %>%
  DT::datatable()
```


```{r}
read_counts_long <- pivot_longer(read_counts, cols = -Status, names_to = "Sample", values_to = "Count")

read_counts_long |>
  ggplot(aes(x = Sample, y = Count, fill = Status)) +
  geom_bar(stat = "identity", position = "dodge") +
  scale_y_log10() +
  labs(
    title = "Feature Counts for Embryo retina/cornea development", 
    x = "Sample", 
    y = "Count") +
  coord_flip() -> plot
  
plot %>%
  ggplotly()
```


All samples exhibit very similar counts, suggesting that up to this point, all my samples were handled consistently, and I have applied a homogeneous analysis to each sample.

## 7. Quality Control

After visualizing my read count data, it is now time to perform quality control (QC) on my *featureCounts.txt* data.

```{r}
## reading in featureCounts output
fc_counts <- read.table("featureCounts.txt" , header = TRUE)

```


```{r}
names(fc_counts) %>%
  stringr::str_remove("_Aligned.sortedByCoord.out.bam") -> names(fc_counts)
```

```{r}
fc_counts %>%
  dplyr::select(1, 7:14) %>%
  dplyr::relocate(E8_retina_rep1, .before = E16_retina_rep1) %>%
  dplyr::relocate(E8_retina_rep2, .after = E8_retina_rep1) %>%
  dplyr::relocate(E18_retina_rep1, .before = E18_cornea_rep1) %>%
  dplyr::relocate(E18_retina_rep2, .after = E18_retina_rep1) -> fc_counts
```


```{r}
row.names(fc_counts) <- make.names(fc_counts$Geneid)
# fc_counts %>%
#   row.names <- make.names(pull(Geneid))
fc_counts$Geneid <- NULL

fc_counts %>%
  as.matrix -> fc_counts_mtx

fc_counts_mtx %>%
  head(5) %>%
  DT::datatable()
```

```{r}
  
fc_counts %>%
  names %>%
  stringr::str_extract(pattern = "^E\\d+") %>%
  data.frame(condition = ., row.names = colnames(fc_counts_mtx)) -> df_coldata

# fc_counts %>%
#   names %>%
#   #stringr::str_extract(pattern = "^_")
#   stringr::str_split(pattern = "_", n = 3) 

fc_counts %>% 
  names %>% 
  stringr::str_extract(pattern = "_[a-z]+_") %>%
  stringr::str_remove(pattern = "_") ->
  df_coldata$region

df_coldata %>%
  #print %>%
  DT::datatable()
  
```

**Set up `DESeq` object:**

```{r}
dds <- DESeqDataSetFromMatrix(countData = fc_counts_mtx,
                       colData = df_coldata,
                       design = ~ condition + region)
dds
```


```{r}
fc_counts[,1:6] -> df_rowdata
rowData(dds) <- df_rowdata

dds
```


```{r}
assay(dds, "counts") %>%
  head %>%
  DT::datatable()
```


```{r}
colSums(counts(dds)) %>% 
  barplot
```

I normalized my counts matrix to ensure that my samples are more comparable.

```{r}
dds %>%
  estimateSizeFactors() -> dds
dds_norm_counts <- counts(dds, normalized = TRUE)

par(mfrow=c(1,2)) # to plot the two box plots next to each other
## bp of non-normalized
boxplot(counts(dds), 
        main = "None-Normalized Read Counts", 
        xlab = "Sample", 
        ylab = "Counts") 
boxplot(dds_norm_counts, 
        main = "Normalized Read Counts", 
        xlab = "Sample", 
        ylab = "Counts")
```


```{r}
par(mfrow=c(1,2)) # to plot the two box plots next to each other
## bp of non-normalized
boxplot(log2(counts(dds) + 1), 
        notch=TRUE,
        main = "Non-normalized Read Counts",
        xlab = "Sample",
        ylab = "log2(read counts)", 
        cex = 0.6)

boxplot(log2(counts(dds, normalize = TRUE) + 1), 
        notch=TRUE,
        main = "Normalized Read Counts",
        xlab = "Sample",
        ylab = "log2(read counts)", 
        cex = 0.6)

```


## 8. Principle Component Analysis (PCA)

Before performing PCA, I applied the `rlogTransformation` to normalize my data.

```{r}
dds %>%
  rlogTransformation %>%
  plotPCA(intgroup = c("condition", "region")) + labs(
    title = "PCA",
  )
```

PC1 explains 68% of the variance in my data. Upon examining the graph, it appears that PC1 has effectively separated my samples based on the optical region. This observation aligns with the expectation that samples from different regions would cluster separately. In essence, it is reasonable to assume that the primary source of variation among my samples is the region from which they were extracted, specifically, the retina and cornea of a chicken embryo.

PC2 explains 21% of the variance, which appears to be associated with embryonic age. Given that E8 represents the earliest time point, it is not surprising that it does not cluster with E16 or E18. This suggests that E8, which I intend to use as my control, exhibits distinct characteristics compared to other time points, regardless of their origin from retina or cornea cells.

This finding holds promise for differential gene expression analysis, indicating that the time points before and after E8 have more significant differences, potentially attributable to developmental events. Since developmental differences are apparent in this PCA, I have high hopes that the developmental genes I am focusing on, such as HOX genes, would yield promising insights. 




